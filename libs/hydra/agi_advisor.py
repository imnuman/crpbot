"""
AGI Advisor - Trade Intelligence from Claude-AGI

This module reads trading recommendations generated by the Claude-AGI
system and provides them to the FTMO runner for pre-trade validation.

Architecture:
- AGI generates recommendations on Finland Dev
- Recommendations are synced to /app/data/hydra/agi_recommendations.json
- FTMO runner queries this advisor before executing trades

Usage:
    from libs.hydra.agi_advisor import get_agi_advisor, should_agi_approve

    advisor = get_agi_advisor()
    approved, reason = advisor.should_trade("gold_london", "XAUUSD", "london")
    size_mult = advisor.get_size_multiplier("gold_london")
"""

import json
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from pathlib import Path
from typing import Dict, List, Optional, Any
from loguru import logger


@dataclass
class BotRecommendation:
    """Recommendation for a specific bot."""
    bot_name: str
    action: str  # "increase_size", "decrease_size", "pause", "normal"
    size_multiplier: float
    reason: str
    confidence: float
    valid_until: str


@dataclass
class SymbolRecommendation:
    """Recommendation for a specific symbol."""
    symbol: str
    bias: str  # "bullish", "bearish", "neutral"
    avoid_sessions: List[str]
    reason: str
    confidence: float


@dataclass
class TradingRecommendations:
    """Full set of trading recommendations."""
    generated_at: str
    expires_at: str
    overall_market: str
    bots: List[BotRecommendation] = field(default_factory=list)
    symbols: List[SymbolRecommendation] = field(default_factory=list)
    alerts: List[str] = field(default_factory=list)
    meta: Dict[str, Any] = field(default_factory=dict)


class AGIAdvisor:
    """
    Client for reading AGI trading recommendations.

    This advisor reads recommendations that are generated by the Claude-AGI
    system and synced to this server. It provides pre-trade validation
    and position sizing guidance.
    """

    # Default recommendations file location
    DEFAULT_RECOMMENDATIONS_PATH = "/app/data/hydra/agi_recommendations.json"

    def __init__(self, recommendations_path: Optional[str] = None):
        self.recommendations_path = Path(
            recommendations_path or self.DEFAULT_RECOMMENDATIONS_PATH
        )
        self._recommendations: Optional[TradingRecommendations] = None
        self._last_load_time: Optional[datetime] = None
        self._load_interval = timedelta(minutes=5)  # Reload every 5 min

        # Try to load recommendations
        self._maybe_reload()

        logger.info(
            f"[AGIAdvisor] Initialized (path={self.recommendations_path}, "
            f"loaded={self._recommendations is not None})"
        )

    def _maybe_reload(self) -> bool:
        """Reload recommendations if needed."""
        now = datetime.now(timezone.utc)

        # Check if we need to reload
        if self._last_load_time and (now - self._last_load_time) < self._load_interval:
            return self._recommendations is not None

        return self._load_recommendations()

    def _load_recommendations(self) -> bool:
        """Load recommendations from file."""
        if not self.recommendations_path.exists():
            logger.debug(f"[AGIAdvisor] No recommendations file at {self.recommendations_path}")
            return False

        try:
            with open(self.recommendations_path, 'r') as f:
                data = json.load(f)

            # Check if expired
            expires_at = data.get("expires_at", "2000-01-01T00:00:00+00:00")
            expires = datetime.fromisoformat(expires_at.replace("Z", "+00:00"))

            if expires < datetime.now(timezone.utc):
                logger.warning(f"[AGIAdvisor] Recommendations expired at {expires_at}")
                self._recommendations = None
                return False

            # Parse recommendations
            self._recommendations = TradingRecommendations(
                generated_at=data.get("generated_at", ""),
                expires_at=data.get("expires_at", ""),
                overall_market=data.get("overall_market", "neutral"),
                bots=[
                    BotRecommendation(**bot) for bot in data.get("bots", [])
                ],
                symbols=[
                    SymbolRecommendation(**sym) for sym in data.get("symbols", [])
                ],
                alerts=data.get("alerts", []),
                meta=data.get("meta", {})
            )

            self._last_load_time = datetime.now(timezone.utc)
            logger.info(
                f"[AGIAdvisor] Loaded recommendations: {len(self._recommendations.bots)} bots, "
                f"{len(self._recommendations.symbols)} symbols, market={self._recommendations.overall_market}"
            )
            return True

        except Exception as e:
            logger.error(f"[AGIAdvisor] Failed to load recommendations: {e}")
            return False

    def get_bot_recommendation(self, bot_name: str) -> Optional[BotRecommendation]:
        """Get recommendation for a specific bot."""
        self._maybe_reload()

        if not self._recommendations:
            return None

        # Normalize bot name for matching
        bot_name_lower = bot_name.lower().replace("_", "").replace("-", "")

        for rec in self._recommendations.bots:
            rec_name = rec.bot_name.lower().replace("_", "").replace("-", "")
            if rec_name == bot_name_lower or bot_name_lower in rec_name or rec_name in bot_name_lower:
                return rec
        return None

    def get_symbol_recommendation(self, symbol: str) -> Optional[SymbolRecommendation]:
        """Get recommendation for a specific symbol."""
        self._maybe_reload()

        if not self._recommendations:
            return None

        # Normalize symbol for matching
        symbol_norm = symbol.upper().replace(".CASH", "").replace("_", "")

        for rec in self._recommendations.symbols:
            rec_symbol = rec.symbol.upper().replace(".CASH", "").replace("_", "")
            if rec_symbol == symbol_norm:
                return rec
        return None

    def should_trade(
        self,
        bot_name: str,
        symbol: str,
        session: Optional[str] = None
    ) -> tuple[bool, str]:
        """
        Check if a trade should proceed based on AGI recommendations.

        Args:
            bot_name: Name of the bot requesting the trade
            symbol: Trading symbol
            session: Current trading session ("asian", "london", "new_york")

        Returns:
            Tuple of (approved: bool, reason: str)
        """
        self._maybe_reload()

        if not self._recommendations:
            return True, "No AGI recommendations available"

        # Check if bot is paused
        bot_rec = self.get_bot_recommendation(bot_name)
        if bot_rec and bot_rec.action == "pause":
            logger.warning(f"[AGIAdvisor] Trade blocked: {bot_name} paused - {bot_rec.reason}")
            return False, f"AGI paused {bot_name}: {bot_rec.reason}"

        # Check symbol session avoidance
        if session:
            symbol_rec = self.get_symbol_recommendation(symbol)
            if symbol_rec and session.lower() in [s.lower() for s in symbol_rec.avoid_sessions]:
                logger.warning(
                    f"[AGIAdvisor] Trade blocked: {symbol} during {session} - {symbol_rec.reason}"
                )
                return False, f"AGI: avoid {symbol} during {session}"

        # Check overall market conditions
        if self._recommendations.overall_market == "risk_off":
            # Allow trade but warn
            logger.info(f"[AGIAdvisor] Risk-off market - proceeding with caution")
            return True, "AGI: risk-off market (use reduced size)"

        return True, "AGI approved"

    def get_size_multiplier(self, bot_name: str) -> float:
        """
        Get recommended position size multiplier for a bot.

        Returns:
            Multiplier (0.0 to 1.5, default 1.0)
        """
        bot_rec = self.get_bot_recommendation(bot_name)
        if bot_rec:
            logger.debug(f"[AGIAdvisor] Size multiplier for {bot_name}: {bot_rec.size_multiplier}x")
            return bot_rec.size_multiplier
        return 1.0

    def get_market_bias(self, symbol: str) -> str:
        """
        Get AGI's market bias for a symbol.

        Returns:
            "bullish", "bearish", or "neutral"
        """
        symbol_rec = self.get_symbol_recommendation(symbol)
        if symbol_rec:
            return symbol_rec.bias
        return "neutral"

    def get_alerts(self) -> List[str]:
        """Get current AGI alerts."""
        self._maybe_reload()
        if self._recommendations:
            return self._recommendations.alerts
        return []

    def get_overall_market(self) -> str:
        """Get overall market assessment."""
        self._maybe_reload()
        if self._recommendations:
            return self._recommendations.overall_market
        return "neutral"

    def get_summary(self) -> str:
        """Get human-readable summary of recommendations."""
        self._maybe_reload()

        if not self._recommendations:
            return "[AGIAdvisor] No active recommendations"

        lines = [
            "[AGIAdvisor] Active Recommendations:",
            f"  Generated: {self._recommendations.generated_at}",
            f"  Market: {self._recommendations.overall_market}",
        ]

        if self._recommendations.alerts:
            lines.append("  Alerts:")
            for alert in self._recommendations.alerts:
                lines.append(f"    ! {alert}")

        bot_actions = {}
        for bot in self._recommendations.bots:
            if bot.action not in bot_actions:
                bot_actions[bot.action] = []
            bot_actions[bot.action].append(f"{bot.bot_name}(x{bot.size_multiplier})")

        if bot_actions:
            lines.append("  Bots:")
            for action, bots in bot_actions.items():
                lines.append(f"    {action}: {', '.join(bots)}")

        return "\n".join(lines)

    def is_active(self) -> bool:
        """Check if AGI recommendations are currently active."""
        self._maybe_reload()
        return self._recommendations is not None

    def get_market_intelligence(self) -> Dict[str, Any]:
        """
        Get market intelligence data from recommendations.

        Returns market_intelligence dict with:
        - fear_greed_crypto: int (0-100)
        - fear_greed_signal: str ("BUY", "SELL", "NEUTRAL")
        - cot_signals: Dict[symbol, "LONG"/"SHORT"]
        - retail_sentiment: Dict[symbol, pct_long]
        - retail_contrarian: Dict[symbol, "CONTRARIAN_SHORT"/"CONTRARIAN_LONG"]
        """
        self._maybe_reload()
        if not self._recommendations or not self._recommendations.meta:
            return {}

        return self._recommendations.meta.get("market_intelligence", {})

    def get_contrarian_signal(self, symbol: str) -> Optional[str]:
        """
        Get contrarian trading signal for a symbol based on retail positioning.

        Returns:
            "CONTRARIAN_SHORT" if retail is 70%+ long (fade the crowd),
            "CONTRARIAN_LONG" if retail is 70%+ short,
            None if no signal or data unavailable
        """
        intel = self.get_market_intelligence()
        retail_contrarian = intel.get("retail_contrarian", {})

        # Normalize symbol
        symbol_norm = symbol.upper().replace(".CASH", "").replace("_", "")

        for key, signal in retail_contrarian.items():
            key_norm = key.upper().replace(".CASH", "").replace("_", "")
            if key_norm == symbol_norm:
                return signal

        return None


# Singleton instance
_instance: Optional[AGIAdvisor] = None


def get_agi_advisor(recommendations_path: Optional[str] = None) -> AGIAdvisor:
    """Get singleton AGIAdvisor instance."""
    global _instance
    if _instance is None:
        _instance = AGIAdvisor(recommendations_path)
    return _instance


def should_agi_approve(
    bot_name: str,
    symbol: str,
    session: Optional[str] = None
) -> tuple[bool, str]:
    """
    Quick check if AGI approves a trade.

    Args:
        bot_name: Name of the bot
        symbol: Trading symbol
        session: Trading session (optional)

    Returns:
        Tuple of (approved, reason)
    """
    return get_agi_advisor().should_trade(bot_name, symbol, session)


def get_agi_size_multiplier(bot_name: str) -> float:
    """Quick helper to get AGI size multiplier for a bot."""
    return get_agi_advisor().get_size_multiplier(bot_name)


if __name__ == "__main__":
    # Test the advisor
    import sys

    # Check if test file exists
    test_path = "/app/data/hydra/agi_recommendations.json"
    if len(sys.argv) > 1:
        test_path = sys.argv[1]

    print(f"Testing AGI Advisor with path: {test_path}")

    advisor = AGIAdvisor(test_path)
    print(advisor.get_summary())

    # Test some queries
    for bot in ["gold_london", "hf_scalper", "eurusd_breakout"]:
        approved, reason = advisor.should_trade(bot, "XAUUSD", "london")
        mult = advisor.get_size_multiplier(bot)
        print(f"\n{bot}: approved={approved}, mult={mult}, reason={reason}")
