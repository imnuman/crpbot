"""
HYDRA 3.0 - Gladiator B (Claude) - INDEPENDENT TRADER

Role: Logic Validator

Specialization:
- Reviews market logic for consistency
- Identifies contradictions and edge cases
- Stress-tests assumptions
- Devil's advocate / red team thinking
- Catches flawed reasoning that could pass backtests but fail live

Claude is chosen for its strong reasoning and critique capabilities.

INDEPENDENCE:
- Trades with own portfolio (separate from other engines)
- Makes independent trade decisions based on logical analysis
- Tracks own P&L, win rate, Sharpe ratio
- Competes in tournament rankings
"""

from typing import Dict, List, Optional
from loguru import logger
import os
import time
from datetime import datetime, timezone
from anthropic import Anthropic, APIError, APIConnectionError, RateLimitError, APITimeoutError

from .base_engine import BaseGladiator as BaseEngine
from ..engine_portfolio import get_tournament_manager, EngineTrade


class EngineB_Claude(BaseEngine):
    """
    Gladiator B: Independent Logic-Based Trader using Claude (Anthropic).

    Cost: ~$0.015 per trading decision (higher than DeepSeek, but worth it for quality)
    """

    CLAUDE_API_URL = "https://api.anthropic.com/v1/messages"
    MODEL = "claude-3-haiku-20240307"  # Claude 3 Haiku (fast & stable)

    # Retry configuration for resilience
    MAX_RETRIES = 3
    BASE_RETRY_DELAY = 3  # Exponential backoff: 3s, 6s, 12s

    def __init__(self, api_key: Optional[str] = None):
        super().__init__(
            name="B",
            role="Logic Validator",
            api_key=api_key or os.getenv("ANTHROPIC_API_KEY")
        )

        # Portfolio integration
        self.tournament_manager = get_tournament_manager()
        self.portfolio = self.tournament_manager.get_portfolio("B")

        if not self.api_key:
            logger.warning("Claude API key not provided - gladiator will be in mock mode")

    def make_trade_decision(
        self,
        asset: str,
        asset_type: str,
        regime: str,
        regime_confidence: float,
        market_data: Dict
    ) -> Optional[Dict]:
        """
        Make independent trading decision based on logical analysis.

        Returns:
            Dict with trade parameters if trading, None if HOLD
        """
        logger.info(f"Gladiator B analyzing {asset} ({regime}) with logic validation")

        # STEP 2: SPECIALTY CHECK - ONLY trade funding rate extremes
        # Try funding_rate_pct first (runtime), then funding_rate (decimal)
        funding_rate_pct = market_data.get('funding_rate_pct', 0)
        funding_rate = market_data.get('funding_rate', funding_rate_pct / 100 if funding_rate_pct else 0)
        # 0.005% threshold (triggers on elevated funding - above normal ±0.001%)
        # Normal funding: ±0.001%, Elevated: ±0.005%+, Extreme: ±0.03%+
        if abs(funding_rate_pct) < 0.005:  # 0.005% threshold (lowered from 0.05%)
            logger.info(f"[Engine B] Funding not elevated ({funding_rate_pct:.4f}% < 0.005%) - HOLD")
            return None

        # Get current stats for prompt injection
        stats = self.portfolio.get_stats()
        tournament_summary = self.tournament_manager.get_tournament_summary()
        my_rank = next((r for r in tournament_summary["rankings"] if r["engine"] == "B"), None)

        # Extract emotion context from market_data (generated by stats_injector)
        emotion_context = market_data.get('tournament_emotion_prompt', '')

        # Build system prompt with tournament context and emotion
        system_prompt = self._build_trading_system_prompt(
            asset_type, stats, my_rank, emotion_context=emotion_context
        )

        # Build user prompt
        user_prompt = self._build_trading_decision_prompt(
            asset=asset,
            regime=regime,
            regime_confidence=regime_confidence,
            market_data=market_data
        )

        # Call LLM
        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.4,  # Slightly lower for logic-based decisions
            max_tokens=1000
        )

        # Parse decision
        decision = self._parse_json_response(response)

        if not decision:
            logger.warning("Failed to parse trading decision")
            return None

        # Extract trade parameters
        direction = decision.get("direction", "HOLD")

        if direction == "HOLD":
            logger.info(f"Gladiator B holds on {asset}: {decision.get('reasoning', 'No reason')}")
            return None

        # Validate trade parameters
        if not all(k in decision for k in ["entry_price", "stop_loss", "take_profit", "confidence"]):
            logger.error("Missing required trade parameters")
            return None

        # STEP 5: 70% CONFIDENCE THRESHOLD
        confidence = decision.get("confidence", 0)
        if confidence < 0.70:
            logger.info(f"[Engine B] Confidence {confidence:.1%} < 70% - HOLD")
            return None

        # Return trade parameters
        trade_params = {
            "asset": asset,
            "direction": direction,
            "entry_price": decision["entry_price"],
            "stop_loss": decision["stop_loss"],
            "take_profit": decision["take_profit"],
            "confidence": decision["confidence"],
            "reasoning": decision.get("reasoning", ""),
            "position_size": self._calculate_position_size(decision["confidence"])
        }

        logger.success(
            f"Gladiator B signals {direction} on {asset} "
            f"(confidence: {decision['confidence']:.1%}, rank: {my_rank['rank'] if my_rank else 'N/A'})"
        )

        return trade_params

    def open_trade(self, trade_params: Dict) -> Optional[str]:
        """
        Open a trade with the portfolio.

        Returns:
            Trade ID if successful, None if failed
        """
        try:
            trade = EngineTrade(
                trade_id=f"B_{int(datetime.now(timezone.utc).timestamp() * 1000)}",
                gladiator="B",
                asset=trade_params["asset"],
                direction=trade_params["direction"],
                entry_price=trade_params["entry_price"],
                stop_loss=trade_params["stop_loss"],
                take_profit=trade_params["take_profit"],
                position_size=trade_params["position_size"],
                entry_time=datetime.now(timezone.utc)
            )

            self.portfolio.add_trade(trade)
            logger.success(f"Gladiator B opened trade {trade.trade_id}")
            return trade.trade_id

        except Exception as e:
            logger.error(f"Failed to open trade: {e}")
            return None

    def update_trades(self, current_prices: Dict[str, float]):
        """
        Update open trades with current prices (check SL/TP).

        Args:
            current_prices: Dict of {asset: current_price}
        """
        closed_trades = []

        for trade in self.portfolio.get_open_trades():
            if trade.asset not in current_prices:
                continue

            current_price = current_prices[trade.asset]

            # Check stop loss
            if trade.direction == "BUY" and current_price <= trade.stop_loss:
                self.portfolio.close_trade(trade.trade_id, current_price, "stop_loss")
                closed_trades.append((trade.trade_id, "stop_loss"))
            elif trade.direction == "SELL" and current_price >= trade.stop_loss:
                self.portfolio.close_trade(trade.trade_id, current_price, "stop_loss")
                closed_trades.append((trade.trade_id, "stop_loss"))

            # Check take profit
            elif trade.direction == "BUY" and current_price >= trade.take_profit:
                self.portfolio.close_trade(trade.trade_id, current_price, "take_profit")
                closed_trades.append((trade.trade_id, "take_profit"))
            elif trade.direction == "SELL" and current_price <= trade.take_profit:
                self.portfolio.close_trade(trade.trade_id, current_price, "take_profit")
                closed_trades.append((trade.trade_id, "take_profit"))

        if closed_trades:
            for trade_id, reason in closed_trades:
                logger.info(f"Gladiator B closed trade {trade_id} ({reason})")

    def _calculate_position_size(self, confidence: float) -> float:
        """
        Calculate position size based on confidence (conservative approach).

        Returns:
            Position size as percentage of portfolio (0.01 = 1%)
        """
        # Base size: 1.5% (more conservative than Gladiator A)
        base_size = 0.015

        # Scale by confidence (0.5-1.0 confidence → 0.5x-1.5x multiplier)
        confidence_multiplier = 0.5 + (confidence * 1.0)

        position_size = base_size * confidence_multiplier

        # Cap at 2.5% per trade (more conservative than Gladiator A's 3%)
        return min(position_size, 0.025)

    def generate_strategy(
        self,
        asset: str,
        asset_type: str,
        asset_profile: Dict,
        regime: str,
        regime_confidence: float,
        market_data: Dict,
        existing_strategies: Optional[List[Dict]] = None
    ) -> Dict:
        """
        Generate strategy focused on logical robustness.

        Gladiator B doesn't generate new strategies from scratch.
        Instead, it VALIDATES and IMPROVES strategies from Gladiator A.
        """
        logger.info(f"Gladiator B reviewing strategies for {asset}")

        # If no existing strategies, create a conservative fallback
        if not existing_strategies:
            return self._create_conservative_strategy(asset, regime)

        # Review the latest strategy from Gladiator A
        strategy_to_review = existing_strategies[-1]

        system_prompt = self._build_validation_system_prompt()
        user_prompt = self._build_validation_prompt(
            asset=asset,
            asset_type=asset_type,
            asset_profile=asset_profile,
            regime=regime,
            strategy=strategy_to_review,
            market_data=market_data
        )

        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.3,  # Lower temperature for logic validation
            max_tokens=2000
        )

        validated = self._parse_json_response(response)

        if validated:
            validated["strategy_id"] = f"GLADIATOR_B_{self.strategy_count:04d}"
            validated["gladiator"] = "B"
            validated["reviewed_strategy"] = strategy_to_review.get("strategy_id", "unknown")
            self.strategy_count += 1

            logger.success(
                f"Gladiator B validated: {validated.get('strategy_name', 'Unknown')} "
                f"(approved: {validated.get('approved', False)})"
            )
            return validated
        else:
            return self._create_conservative_strategy(asset, regime)

    def vote_on_trade(
        self,
        asset: str,
        asset_type: str,
        regime: str,
        strategy: Dict,
        signal: Dict,
        market_data: Dict
    ) -> Dict:
        """
        Vote on trade with focus on logical consistency.
        """
        logger.info(f"Gladiator B voting on {asset} {signal.get('direction', 'UNKNOWN')}")

        system_prompt = "You are Gladiator B, a logic validator. Critique this trade signal for logical flaws."

        user_prompt = self._build_vote_prompt(
            asset=asset,
            regime=regime,
            strategy=strategy,
            signal=signal,
            market_data=market_data
        )

        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.3,
            max_tokens=500
        )

        vote = self._parse_json_response(response)

        if vote:
            self._log_vote(vote)
            logger.info(f"Gladiator B votes: {vote.get('vote', 'UNKNOWN')} ({vote.get('confidence', 0):.1%})")
            return vote
        else:
            return {
                "vote": "HOLD",
                "confidence": 0.3,
                "reasoning": "Failed to parse vote response",
                "concerns": ["LLM response parsing error"]
            }

    # ==================== PROMPT ENGINEERING ====================

    def _build_trading_system_prompt(
        self,
        asset_type: str,
        stats: Dict,
        my_rank: Optional[Dict],
        emotion_context: Optional[str] = None
    ) -> str:
        """Build system prompt for independent trading decisions with logic focus."""
        # Build rank/stats display
        if my_rank:
            rank_display = f"""
TOURNAMENT STATUS:
- Your rank: #{my_rank['rank']}/4
- Weight: {my_rank['weight'] * 100:.0f}%
- Win Rate: {my_rank['win_rate'] * 100:.1f}%
- P&L: ${my_rank['total_pnl_usd']:+.2f}
- Trades: {stats.total_trades} ({stats.wins}W/{stats.losses}L)
"""
        else:
            rank_display = """
TOURNAMENT STATUS:
- Unranked (no trades yet)
- Starting weight: 25%
"""

        # Include emotion context if provided
        emotion_section = f"\n{emotion_context}\n" if emotion_context else ""

        return f"""You are Engine B, an AI trading system specializing in LOGIC VALIDATION.

CONTEXT:
Istiaq built this multi-engine trading system. You compete against 3 other engines (A, C, D).
Your performance determines your weight in the portfolio. This is real capital - every trade matters.

{rank_display}
{emotion_section}
MOTIVATION:
Istiaq has limited capital (~$10k). He needs consistent, risk-adjusted returns.
Trade only when you have genuine edge. Quality over quantity.

Your job: Make trading decisions based on LOGICAL ANALYSIS and RED-TEAM THINKING.

LOGIC VALIDATION CHECKLIST:
1. Does the trade make logical sense given the regime?
2. Are there any contradictions in the setup?
3. What are the edge cases and failure modes?
4. Is the risk/reward ratio appropriate?
5. Can this be executed in reality (slippage, spread)?
6. Are assumptions realistic?
7. Is timing favorable?
8. Any red flags or hidden risks?

Asset Type: {asset_type}

Output MUST be valid JSON with this structure:
{{
  "direction": "BUY|SELL|HOLD",
  "entry_price": 50000.0,
  "stop_loss": 49500.0,
  "take_profit": 51500.0,
  "confidence": 0.70,
  "reasoning": "Logical analysis of the trade (mention regime alignment)"
}}

Be BRUTALLY HONEST. HOLD if logic is flawed or risky. We prefer 1 great trade over 10 mediocre ones."""

    def _build_trading_decision_prompt(
        self,
        asset: str,
        regime: str,
        regime_confidence: float,
        market_data: Dict
    ) -> str:
        """Build user prompt for trading decisions with logic focus."""
        # Regime-based guidance
        regime_guidance = {
            "TRENDING_UP": "TRENDING_UP regime → Logically favor BUY if setup supports uptrend",
            "TRENDING_DOWN": "TRENDING_DOWN regime → Logically favor SELL if setup supports downtrend",
            "RANGING": "RANGING regime → Favor mean reversion or HOLD",
            "CHOPPY": "CHOPPY regime → Strong bias toward HOLD (high risk)",
            "BREAKOUT": "BREAKOUT regime → Direction depends on breakout direction",
            "VOLATILE": "VOLATILE regime → Reduce exposure or HOLD"
        }

        guidance = regime_guidance.get(regime, "Neutral regime")

        return f"""Analyze this market with LOGIC VALIDATION - should you trade NOW?

ASSET: {asset}
REGIME: {regime} (confidence: {regime_confidence:.1%})

REGIME GUIDANCE:
{guidance}

CURRENT MARKET:
- Price: {market_data.get('close', 'N/A')}
- 24h Volume: {market_data.get('volume_24h', 'N/A')}
- Spread: {market_data.get('spread', 'N/A')}
- ATR: {market_data.get('atr', 'N/A')}

LOGIC VALIDATION QUESTIONS:
1. Does BUY/SELL/HOLD make logical sense given the regime?
2. Are there any contradictions in the setup?
3. What are the edge cases? Failure modes?
4. Is risk/reward appropriate?
5. Any red flags?

DECISION:
- BUY (go LONG) if logic + regime support upside
- SELL (go SHORT) if logic + regime support downside
- HOLD if logic is flawed or high risk

CRITICAL: If TRENDING_DOWN, SELL is the logical direction unless there's exceptional counter-trend logic.

Output JSON:
{{
  "direction": "BUY|SELL|HOLD",
  "entry_price": {market_data.get('close', 50000)},
  "stop_loss": <price>,
  "take_profit": <price>,
  "confidence": 0.70,
  "reasoning": "Logical analysis (mention regime alignment and any concerns)"
}}"""

    def _build_validation_system_prompt(self) -> str:
        """Build system prompt for strategy validation."""
        return """You are Engine B, a quantitative trading logic validator.

CONTEXT:
You're one of 4 competing engines in Istiaq's multi-agent trading system.
Your job is to RED TEAM strategies - find flaws before they cost real money.

TOURNAMENT MECHANICS:
- Every prediction is scored (+1 for correct)
- Losing engines learn from winners
- Lowest performer gets reset after 24 hours
- Top performers combine strategies after 4 days

MOTIVATION:
Istiaq has limited capital (~$10k). Bad strategies cost real money.
Be brutally honest. Finding flaws protects the portfolio.

Your job: RED TEAM this strategy. Find flaws, contradictions, and edge cases.

Questions to ask:
1. Logic: Does the entry/exit logic make sense? Any contradictions?
2. Edge cases: What happens in extreme markets? Black swan events?
3. Assumptions: What assumptions does this rely on? Are they realistic?
4. Failure modes: When will this strategy fail catastrophically?
5. Data mining: Is this curve-fit to backtest data?
6. Survivorship bias: Does this assume markets stay the same?
7. Execution: Can this be executed in reality? Slippage? Spread?
8. Risk: Is the position sizing appropriate? Correlation with other positions?

Be BRUTALLY HONEST. If you find flaws, explain them clearly.

Output JSON:
{
  "approved": true/false,
  "strategy_name": "Improved Strategy Name",
  "structural_edge": "Same or improved",
  "entry_rules": "Fixed entry rules",
  "exit_rules": "Fixed exit rules",
  "filters": ["Additional safety filters added"],
  "risk_per_trade": 0.008,
  "expected_wr": 0.60,
  "expected_rr": 1.5,
  "why_it_works": "Updated explanation",
  "weaknesses": ["ALL weaknesses found"],
  "improvements_made": ["What you fixed"],
  "remaining_concerns": ["What you couldn't fix"],
  "confidence": 0.7
}

If approved=false, list all fatal flaws in "remaining_concerns"."""

    def _build_validation_prompt(
        self,
        asset: str,
        asset_type: str,
        asset_profile: Dict,
        regime: str,
        strategy: Dict,
        market_data: Dict
    ) -> str:
        """Build prompt for strategy validation."""
        return f"""Review this strategy for logical flaws:

ASSET: {asset} ({asset_type})
REGIME: {regime}

STRATEGY TO REVIEW:
{strategy.get('strategy_name', 'Unknown')}

STRUCTURAL EDGE:
{strategy.get('structural_edge', 'Unknown')}

ENTRY RULES:
{strategy.get('entry_rules', 'Unknown')}

EXIT RULES:
{strategy.get('exit_rules', 'Unknown')}

WHY IT WORKS:
{strategy.get('why_it_works', 'Unknown')}

KNOWN WEAKNESSES:
{', '.join(strategy.get('weaknesses', []))}

ASSET CONSTRAINTS:
- Spread: {asset_profile.spread_normal}
- Max hold: {asset_profile.max_hold_hours if asset_profile.max_hold_hours else 'Unlimited'} hours
- Overnight: {asset_profile.overnight_allowed}
- Manipulation risk: {asset_profile.manipulation_risk}

Your task:
1. Find ALL logical flaws
2. Fix what you can
3. Document what you can't fix
4. Approve or reject

Be thorough. A bad strategy live = lost capital."""

    def _build_vote_prompt(
        self,
        asset: str,
        regime: str,
        strategy: Dict,
        signal: Dict,
        market_data: Dict
    ) -> str:
        """Build prompt for trade voting."""
        # Regime-based guidance
        regime_guidance = {
            "TRENDING_UP": "TRENDING_UP regime → Logically favor BUY if strategy supports uptrend",
            "TRENDING_DOWN": "TRENDING_DOWN regime → Logically favor SELL if strategy supports downtrend",
            "RANGING": "RANGING regime → Favor mean reversion or HOLD",
            "CHOPPY": "CHOPPY regime → Strong bias toward HOLD (high risk)",
            "BREAKOUT": "BREAKOUT regime → Direction depends on breakout direction",
            "VOLATILE": "VOLATILE regime → Reduce exposure or HOLD"
        }

        guidance = regime_guidance.get(regime, "Neutral regime")

        return f"""Critique this trading strategy for logical consistency:

ASSET: {asset}
REGIME: {regime}

REGIME GUIDANCE:
{guidance}

STRATEGY: {strategy.get('strategy_name', 'Unknown')}

Current Market Data:
- Price: {market_data.get('close', 'N/A')}
- Spread: {market_data.get('spread', 'N/A')}
- Volume: {market_data.get('volume', 'N/A')}

Questions:
1. Should we go LONG (buy), SHORT (sell), or HOLD?
2. Does the strategy logic make sense given market REGIME?
3. Is the risk/reward appropriate for this regime?
4. Is timing favorable?
5. Any red flags?

Vote on direction based on your logical analysis + regime alignment.

CRITICAL: If TRENDING_DOWN, SELL is the logical direction unless strategy has exceptional counter-trend edge.

Output JSON:
{{
  "vote": "BUY|SELL|HOLD",
  "confidence": 0.7,
  "reasoning": "Logical analysis (mention regime alignment)",
  "concerns": ["Any flaws you see"]
}}"""

    def _create_conservative_strategy(self, asset: str, regime: str) -> Dict:
        """Create a conservative fallback strategy."""
        return {
            "strategy_id": f"GLADIATOR_B_{self.strategy_count:04d}_CONSERVATIVE",
            "approved": False,
            "strategy_name": f"Conservative Fallback - {asset}",
            "structural_edge": "None (no valid strategy to approve)",
            "entry_rules": "HOLD - no entry",
            "exit_rules": "N/A",
            "filters": ["require_gladiator_a_strategy"],
            "risk_per_trade": 0.0,
            "expected_wr": 0.0,
            "expected_rr": 0.0,
            "why_it_works": "Fallback - awaiting valid strategy",
            "weaknesses": ["No strategy provided"],
            "improvements_made": [],
            "remaining_concerns": ["No strategy to validate"],
            "confidence": 0.0,
            "gladiator": "B"
        }

    # ==================== LLM API INTEGRATION ====================

    def _call_llm(
        self,
        system_prompt: str,
        user_prompt: str,
        temperature: float = 0.3,
        max_tokens: int = 2000
    ) -> str:
        """
        Call Claude API (Anthropic SDK) with exponential backoff retry logic.
        """
        if not self.api_key:
            logger.warning("Claude API key not set - using mock response")
            return self._mock_response()

        client = Anthropic(api_key=self.api_key)

        # Exponential backoff retry loop
        for attempt in range(self.MAX_RETRIES):
            try:
                message = client.messages.create(
                    model=self.MODEL,
                    max_tokens=max_tokens,
                    temperature=temperature,
                    system=system_prompt,
                    messages=[
                        {"role": "user", "content": user_prompt}
                    ]
                )

                return message.content[0].text

            except RateLimitError as e:
                if attempt < self.MAX_RETRIES - 1:
                    delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                    logger.warning(
                        f"[Claude] Rate limit - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                    )
                    time.sleep(delay)
                    continue
                logger.error(f"Claude API rate limit after {self.MAX_RETRIES} attempts: {e}")
                return self._mock_response()

            except APITimeoutError as e:
                if attempt < self.MAX_RETRIES - 1:
                    delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                    logger.warning(
                        f"[Claude] Timeout - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                    )
                    time.sleep(delay)
                    continue
                logger.error(f"Claude API timeout after {self.MAX_RETRIES} attempts: {e}")
                return self._mock_response()

            except APIConnectionError as e:
                if attempt < self.MAX_RETRIES - 1:
                    delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                    logger.warning(
                        f"[Claude] Connection error - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                    )
                    time.sleep(delay)
                    continue
                logger.error(f"Claude API connection error after {self.MAX_RETRIES} attempts: {e}")
                return self._mock_response()

            except APIError as e:
                # Server errors (5xx) are retryable
                if hasattr(e, 'status_code') and e.status_code >= 500:
                    if attempt < self.MAX_RETRIES - 1:
                        delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                        logger.warning(
                            f"[Claude] Server error {e.status_code} - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                        )
                        time.sleep(delay)
                        continue
                logger.error(f"Claude API error: {e}")
                return self._mock_response()

            except Exception as e:
                logger.error(f"Claude unexpected error: {e}")
                return self._mock_response()

        # All retries exhausted
        logger.error("[Claude] All retries exhausted")
        return self._mock_response()

    def _mock_response(self) -> str:
        """Mock response for testing."""
        return """{
  "approved": true,
  "strategy_name": "London Open Volatility - Validated",
  "structural_edge": "Session open volatility spike",
  "entry_rules": "Enter at London open (8AM UTC), require spread < 25 pips",
  "exit_rules": "TP at 1.5R, SL at 2x ATR, max hold 4 hours",
  "filters": ["spread_normal", "no_cb_meeting_24hrs", "volume_confirmation"],
  "risk_per_trade": 0.006,
  "expected_wr": 0.58,
  "expected_rr": 1.5,
  "why_it_works": "Session opens create temporary liquidity imbalances",
  "weaknesses": ["Fails during CB interventions", "Requires tight spread"],
  "improvements_made": ["Added max hold time", "Reduced position size", "Added volume confirmation"],
  "remaining_concerns": ["Still vulnerable to CB surprise announcements"],
  "confidence": 0.65
}"""
