"""
HYDRA 3.0 - Gladiator A (DeepSeek) - INDEPENDENT TRADER

Role: Structural Edge Generator

Specialization:
- Identifies STRUCTURAL edges (not chart patterns)
- Focuses on market mechanics (funding, liquidations, session timing)
- BANS retail patterns (double tops, head & shoulders, etc.)
- Uses first-principles thinking

DeepSeek is chosen for its reasoning capabilities at low cost.

INDEPENDENCE:
- Trades with own portfolio (separate from other engines)
- Makes independent trade decisions (no consensus voting)
- Tracks own P&L, win rate, Sharpe ratio
- Competes in tournament rankings
"""

from typing import Dict, List, Optional
from loguru import logger
import requests
import os
import time
from datetime import datetime, timezone

from .base_engine import BaseGladiator as BaseEngine
from ..engine_portfolio import get_tournament_manager, EngineTrade


class EngineA_DeepSeek(BaseEngine):
    """
    Gladiator A: Independent Structural Edge Trader using DeepSeek.

    Cost: ~$0.0001 per trading decision
    """

    DEEPSEEK_API_URL = "https://api.deepseek.com/v1/chat/completions"
    MODEL = "deepseek-chat"  # Latest DeepSeek model

    # Retry configuration for resilience
    MAX_RETRIES = 3
    BASE_RETRY_DELAY = 3  # Exponential backoff: 3s, 6s, 12s

    def __init__(self, api_key: Optional[str] = None):
        super().__init__(
            name="A",
            role="Structural Edge Generator",
            api_key=api_key or os.getenv("DEEPSEEK_API_KEY")
        )

        # Portfolio integration
        self.tournament_manager = get_tournament_manager()
        self.portfolio = self.tournament_manager.get_portfolio("A")

        if not self.api_key:
            logger.warning("DeepSeek API key not provided - gladiator will be in mock mode")

    def make_trade_decision(
        self,
        asset: str,
        asset_type: str,
        regime: str,
        regime_confidence: float,
        market_data: Dict
    ) -> Optional[Dict]:
        """
        Make independent trading decision (replaces consensus voting).

        Returns:
            Dict with trade parameters if trading, None if HOLD
        """
        logger.info(f"Gladiator A analyzing {asset} ({regime})")

        # STEP 1: SPECIALTY CHECK - ONLY trade liquidation cascades
        # Try both keys (runtime uses different names)
        liquidation_amount = market_data.get('liquidation_15m', 0) or market_data.get('liquidation_total_usd', 0)
        if liquidation_amount < 1_000_000:  # $1M threshold (matches specialty config)
            logger.info(f"[Engine A] No liquidation cascade (${liquidation_amount:,.0f} < $1M) - HOLD")
            return None

        # Get current stats for prompt injection
        stats = self.portfolio.get_stats()
        tournament_summary = self.tournament_manager.get_tournament_summary()
        my_rank = next((r for r in tournament_summary["rankings"] if r["engine"] == "A"), None)

        # Extract emotion context from market_data (generated by stats_injector)
        emotion_context = market_data.get('tournament_emotion_prompt', '')

        # Build system prompt with tournament context and emotion
        system_prompt = self._build_trading_system_prompt(
            asset_type, stats, my_rank, emotion_context=emotion_context
        )

        # Build user prompt
        user_prompt = self._build_trading_decision_prompt(
            asset=asset,
            regime=regime,
            regime_confidence=regime_confidence,
            market_data=market_data
        )

        # Call LLM
        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.6,  # Balanced for trading decisions
            max_tokens=1000
        )

        # Parse decision
        decision = self._parse_json_response(response)

        if not decision:
            logger.warning("Failed to parse trading decision")
            return None

        # Extract trade parameters
        direction = decision.get("direction", "HOLD")

        if direction == "HOLD":
            logger.info(f"Gladiator A holds on {asset}: {decision.get('reasoning', 'No reason')}")
            return None

        # Validate trade parameters
        if not all(k in decision for k in ["entry_price", "stop_loss", "take_profit", "confidence"]):
            logger.error("Missing required trade parameters")
            return None

        # STEP 5: 55% CONFIDENCE THRESHOLD (lowered from 70% for more trades)
        confidence = decision.get("confidence", 0)
        if confidence < 0.55:
            logger.info(f"[Engine A] Confidence {confidence:.1%} < 55% - HOLD")
            return None

        # Return trade parameters
        trade_params = {
            "asset": asset,
            "direction": direction,
            "entry_price": decision["entry_price"],
            "stop_loss": decision["stop_loss"],
            "take_profit": decision["take_profit"],
            "confidence": decision["confidence"],
            "reasoning": decision.get("reasoning", ""),
            "position_size": self._calculate_position_size(decision["confidence"])
        }

        logger.success(
            f"Gladiator A signals {direction} on {asset} "
            f"(confidence: {decision['confidence']:.1%}, rank: {my_rank['rank'] if my_rank else 'N/A'})"
        )

        return trade_params

    def open_trade(self, trade_params: Dict) -> Optional[str]:
        """
        Open a trade with the portfolio.

        Returns:
            Trade ID if successful, None if failed
        """
        try:
            trade = EngineTrade(
                trade_id=f"A_{int(datetime.now(timezone.utc).timestamp() * 1000)}",
                gladiator="A",
                asset=trade_params["asset"],
                direction=trade_params["direction"],
                entry_price=trade_params["entry_price"],
                stop_loss=trade_params["stop_loss"],
                take_profit=trade_params["take_profit"],
                position_size=trade_params["position_size"],
                entry_time=datetime.now(timezone.utc)
            )

            self.portfolio.add_trade(trade)
            logger.success(f"Gladiator A opened trade {trade.trade_id}")
            return trade.trade_id

        except Exception as e:
            logger.error(f"Failed to open trade: {e}")
            return None

    def update_trades(self, current_prices: Dict[str, float]):
        """
        Update open trades with current prices (check SL/TP).

        Args:
            current_prices: Dict of {asset: current_price}
        """
        closed_trades = []

        for trade in self.portfolio.get_open_trades():
            if trade.asset not in current_prices:
                continue

            current_price = current_prices[trade.asset]

            # Check stop loss
            if trade.direction == "BUY" and current_price <= trade.stop_loss:
                self.portfolio.close_trade(trade.trade_id, current_price, "stop_loss")
                closed_trades.append((trade.trade_id, "stop_loss"))
            elif trade.direction == "SELL" and current_price >= trade.stop_loss:
                self.portfolio.close_trade(trade.trade_id, current_price, "stop_loss")
                closed_trades.append((trade.trade_id, "stop_loss"))

            # Check take profit
            elif trade.direction == "BUY" and current_price >= trade.take_profit:
                self.portfolio.close_trade(trade.trade_id, current_price, "take_profit")
                closed_trades.append((trade.trade_id, "take_profit"))
            elif trade.direction == "SELL" and current_price <= trade.take_profit:
                self.portfolio.close_trade(trade.trade_id, current_price, "take_profit")
                closed_trades.append((trade.trade_id, "take_profit"))

        if closed_trades:
            for trade_id, reason in closed_trades:
                logger.info(f"Gladiator A closed trade {trade_id} ({reason})")

    def _calculate_position_size(self, confidence: float) -> float:
        """
        Calculate position size based on confidence.

        Returns:
            Position size as percentage of portfolio (0.01 = 1%)
        """
        # Base size: 2% of portfolio
        base_size = 0.02

        # Scale by confidence (0.5-1.0 confidence → 0.5x-1.5x multiplier)
        confidence_multiplier = 0.5 + (confidence * 1.0)

        position_size = base_size * confidence_multiplier

        # Cap at 3% per trade
        return min(position_size, 0.03)

    def generate_strategy(
        self,
        asset: str,
        asset_type: str,
        asset_profile: Dict,
        regime: str,
        regime_confidence: float,
        market_data: Dict,
        existing_strategies: Optional[List[Dict]] = None
    ) -> Dict:
        """
        Generate structural edge strategy for this asset/regime.
        """
        logger.info(f"Gladiator A generating strategy for {asset} ({regime})")

        # Build system prompt
        system_prompt = self._build_system_prompt(asset_type)

        # Build user prompt with all context
        user_prompt = self._build_strategy_generation_prompt(
            asset=asset,
            asset_type=asset_type,
            asset_profile=asset_profile,
            regime=regime,
            regime_confidence=regime_confidence,
            market_data=market_data,
            existing_strategies=existing_strategies
        )

        # Call DeepSeek API
        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.7,
            max_tokens=2000
        )

        # Parse JSON response
        strategy = self._parse_json_response(response)

        if strategy:
            # Add metadata
            strategy["strategy_id"] = f"GLADIATOR_A_{self.strategy_count:04d}"
            strategy["gladiator"] = "A"
            strategy["generated_at"] = market_data.get("timestamp", "unknown")
            self.strategy_count += 1

            logger.success(
                f"Gladiator A generated: {strategy.get('strategy_name', 'Unknown')} "
                f"(confidence: {strategy.get('confidence', 0):.1%})"
            )
            return strategy
        else:
            logger.error("Failed to parse strategy from DeepSeek response")
            return self._fallback_strategy(asset, regime)

    def vote_on_trade(
        self,
        asset: str,
        asset_type: str,
        regime: str,
        strategy: Dict,
        signal: Dict,
        market_data: Dict
    ) -> Dict:
        """
        Vote on whether to take a specific trade.
        """
        logger.info(f"Gladiator A voting on {asset} {signal.get('direction', 'UNKNOWN')}")

        system_prompt = "You are Gladiator A, a structural edge specialist. Vote on this trade signal."

        user_prompt = self._build_vote_prompt(
            asset=asset,
            asset_type=asset_type,
            regime=regime,
            strategy=strategy,
            signal=signal,
            market_data=market_data
        )

        response = self._call_llm(
            system_prompt=system_prompt,
            user_prompt=user_prompt,
            temperature=0.5,  # Lower temperature for voting
            max_tokens=500
        )

        vote = self._parse_json_response(response)

        if vote:
            self._log_vote(vote)
            logger.info(f"Gladiator A votes: {vote.get('vote', 'UNKNOWN')} ({vote.get('confidence', 0):.1%})")
            return vote
        else:
            # Fallback vote
            return {
                "vote": "HOLD",
                "confidence": 0.3,
                "reasoning": "Failed to parse vote response",
                "concerns": ["LLM response parsing error"]
            }

    # ==================== PROMPT ENGINEERING ====================

    def _build_trading_system_prompt(
        self,
        asset_type: str,
        stats: Dict,
        my_rank: Optional[Dict],
        emotion_context: Optional[str] = None
    ) -> str:
        """Build system prompt for independent trading decisions."""
        # Build rank/stats display
        if my_rank:
            rank_display = f"""
TOURNAMENT STATUS:
- Your rank: #{my_rank['rank']}/4
- Weight: {my_rank['weight'] * 100:.0f}%
- Win Rate: {my_rank['win_rate'] * 100:.1f}%
- P&L: ${my_rank['total_pnl_usd']:+.2f}
- Trades: {stats.total_trades} ({stats.wins}W/{stats.losses}L)
"""
        else:
            rank_display = """
TOURNAMENT STATUS:
- Unranked (no trades yet)
- Starting weight: 25%
"""

        # Include emotion context if provided
        emotion_section = f"\n{emotion_context}\n" if emotion_context else ""

        return f"""You are Engine A, an AI trading system specializing in STRUCTURAL edges.

CONTEXT:
Istiaq built this multi-engine trading system. You compete against 3 other engines (B, C, D).
Your performance determines your weight in the portfolio. This is real capital - every trade matters.

{rank_display}
{emotion_section}
MOTIVATION:
Istiaq has limited capital (~$10k). He needs consistent, risk-adjusted returns.
Trade only when you have genuine edge. Quality over quantity.

Your job: Make trading decisions based on MARKET MECHANICS, not chart patterns.

BANNED PATTERNS (never use these):
- Double tops / double bottoms
- Head and shoulders
- Triangles, wedges, flags
- Support/resistance lines
- Fibonacci retracements
- Moving average crossovers
- RSI overbought/oversold
- MACD divergences

ALLOWED EDGES (use ONLY these):
1. Funding rate arbitrage (crypto perps)
2. Liquidation clusters (hunt stops)
3. Session timing (London/NY open volatility)
4. Carry trade unwinding
5. Whale movements (large wallet transfers)
6. Order book imbalances (spoofing detection)
7. Cross-asset correlation breaks
8. Central bank intervention patterns
9. Market maker behavior (spread widening)
10. Time-of-day patterns (Asia session pumps)

Asset Type: {asset_type}

Output MUST be valid JSON with this structure:
{{
  "direction": "BUY|SELL|HOLD",
  "entry_price": 50000.0,
  "stop_loss": 49500.0,
  "take_profit": 51500.0,
  "confidence": 0.75,
  "reasoning": "Why you chose this direction (mention structural edge)"
}}

Be BRUTALLY HONEST. HOLD if no clear edge. We prefer 1 great trade over 10 mediocre ones."""

    def _build_trading_decision_prompt(
        self,
        asset: str,
        regime: str,
        regime_confidence: float,
        market_data: Dict
    ) -> str:
        """Build user prompt for trading decisions."""
        # Regime-based guidance
        regime_guidance = {
            "TRENDING_UP": "TRENDING_UP regime → Favor BUY (longs) if structural edge supports upside momentum",
            "TRENDING_DOWN": "TRENDING_DOWN regime → Favor SELL (shorts) if structural edge supports downside momentum",
            "RANGING": "RANGING regime → Favor mean reversion or HOLD until breakout confirmed",
            "CHOPPY": "CHOPPY regime → Strong bias toward HOLD unless edge is exceptional",
            "BREAKOUT": "BREAKOUT regime → Favor BUY if breaking up, SELL if breaking down",
            "VOLATILE": "VOLATILE regime → Reduce position size or HOLD unless edge is very strong"
        }

        guidance = regime_guidance.get(regime, "Neutral regime → Evaluate edge without directional bias")

        return f"""Should you trade this asset NOW?

ASSET: {asset}
REGIME: {regime} (confidence: {regime_confidence:.1%})

REGIME GUIDANCE:
{guidance}

CURRENT MARKET:
- Price: {market_data.get('close', 'N/A')}
- 24h Volume: {market_data.get('volume_24h', 'N/A')}
- Spread: {market_data.get('spread', 'N/A')}
- ATR: {market_data.get('atr', 'N/A')}

DECISION:
- BUY (go LONG) if structural edge + regime favor upside
- SELL (go SHORT) if structural edge + regime favor downside
- HOLD if no clear edge or high risk

CRITICAL: Match your decision to the regime! TRENDING_DOWN should produce SELL signals, not BUY.

Output JSON:
{{
  "direction": "BUY|SELL|HOLD",
  "entry_price": {market_data.get('close', 50000)},
  "stop_loss": <price>,
  "take_profit": <price>,
  "confidence": 0.75,
  "reasoning": "Why you chose this direction (mention regime alignment)"
}}"""

    def _build_system_prompt(self, asset_type: str) -> str:
        """Build system prompt for strategy generation."""
        return f"""You are Engine A, an AI trading system specializing in STRUCTURAL edges.

CONTEXT:
You're one of 4 competing engines in Istiaq's multi-agent trading system.
Your strategies are tracked and scored. Performance determines your weight.

TOURNAMENT MECHANICS:
- Every prediction is scored (+1 for correct)
- Losing engines learn from winners
- Lowest performer gets reset after 24 hours
- Top performers combine strategies after 4 days

MOTIVATION:
Istiaq has limited capital (~$10k). He needs consistent returns, not experiments.
Generate strategies with genuine edge. Quality over quantity.

Your job: Generate trading strategies based on MARKET MECHANICS, not chart patterns.

BANNED PATTERNS (never use these):
- Double tops / double bottoms
- Head and shoulders
- Triangles, wedges, flags
- Support/resistance lines
- Fibonacci retracements
- Moving average crossovers
- RSI overbought/oversold
- MACD divergences

ALLOWED EDGES (use ONLY these):
1. Funding rate arbitrage (crypto perps)
2. Liquidation clusters (hunt stops)
3. Session timing (London/NY open volatility)
4. Carry trade unwinding
5. Whale movements (large wallet transfers)
6. Order book imbalances (spoofing detection)
7. Cross-asset correlation breaks
8. Central bank intervention patterns
9. Market maker behavior (spread widening)
10. Time-of-day patterns (Asia session pumps)

Asset Type: {asset_type}

Output MUST be valid JSON with this structure:
{{
  "strategy_name": "Clear, descriptive name",
  "structural_edge": "Which mechanic are you exploiting?",
  "entry_rules": "Precise entry conditions",
  "exit_rules": "Precise exit conditions (TP/SL)",
  "filters": ["List of required filters"],
  "risk_per_trade": 0.008,
  "expected_wr": 0.63,
  "expected_rr": 1.5,
  "why_it_works": "First-principles explanation",
  "weaknesses": ["Known failure modes"],
  "confidence": 0.75
}}

Be BRUTALLY HONEST about weaknesses. We prefer 1 great strategy over 10 mediocre ones."""

    def _build_strategy_generation_prompt(
        self,
        asset: str,
        asset_type: str,
        asset_profile: Dict,
        regime: str,
        regime_confidence: float,
        market_data: Dict,
        existing_strategies: Optional[List[Dict]]
    ) -> str:
        """Build user prompt for strategy generation."""
        prompt = f"""Generate a structural edge strategy for this market:

ASSET: {asset}
TYPE: {asset_type}
REGIME: {regime} (confidence: {regime_confidence:.1%})

ASSET PROFILE:
- Spread (normal): {asset_profile.spread_normal}
- Manipulation risk: {asset_profile.manipulation_risk}
- Best sessions: {', '.join(asset_profile.best_sessions)}
- Overnight allowed: {asset_profile.overnight_allowed}
- Max hold: {asset_profile.max_hold_hours if asset_profile.max_hold_hours else 'Unlimited'} hours
- Special rules: {', '.join(asset_profile.special_rules)[:200]}

MARKET DATA:
- Current price: {market_data.get('close', 'N/A')}
- 24h volume: {market_data.get('volume_24h', 'N/A')}
- ATR: {market_data.get('atr', 'N/A')}
"""

        if asset_type == "meme_perp":
            funding_threshold = asset_profile.funding_threshold if asset_profile.funding_threshold else 'N/A'
            whale_threshold = asset_profile.whale_threshold if asset_profile.whale_threshold else 'N/A'
            whale_str = f"${whale_threshold:,}" if whale_threshold != 'N/A' else 'N/A'
            prompt += f"""
CRYPTO-SPECIFIC:
- Funding rate: {market_data.get('funding_rate', 'N/A')}
- Funding threshold: {funding_threshold}
- Whale threshold: {whale_str}
"""

        if existing_strategies:
            prompt += f"\nEXISTING STRATEGIES: {len(existing_strategies)} already generated (avoid duplication)"

        prompt += "\n\nGenerate a NEW structural edge strategy that exploits this market's unique characteristics."

        return prompt

    def _build_vote_prompt(
        self,
        asset: str,
        asset_type: str,
        regime: str,
        strategy: Dict,
        signal: Dict,
        market_data: Dict
    ) -> str:
        """Build prompt for voting on a trade."""
        # Regime-based guidance
        regime_guidance = {
            "TRENDING_UP": "TRENDING_UP regime → Favor BUY (longs) if edge supports upside momentum",
            "TRENDING_DOWN": "TRENDING_DOWN regime → Favor SELL (shorts) if edge supports downside momentum",
            "RANGING": "RANGING regime → Favor mean reversion or HOLD until breakout confirmed",
            "CHOPPY": "CHOPPY regime → Strong bias toward HOLD unless edge is exceptional",
            "BREAKOUT": "BREAKOUT regime → Favor BUY if breaking up, SELL if breaking down",
            "VOLATILE": "VOLATILE regime → Reduce position size or HOLD unless edge is very strong"
        }

        guidance = regime_guidance.get(regime, "Neutral regime → Evaluate edge without directional bias")

        return f"""Based on this market analysis, should we trade this asset?

ASSET: {asset}
REGIME: {regime}

REGIME GUIDANCE:
{guidance}

STRATEGY: {strategy.get('strategy_name', 'Unknown')}
STRUCTURAL EDGE: {strategy.get('structural_edge', 'Unknown')}

CURRENT MARKET:
- Price: {market_data.get('close', 'N/A')}
- Spread: {market_data.get('spread', 'N/A')}
- Volume: {market_data.get('volume', 'N/A')}

VOTE ON DIRECTION:
- BUY (go LONG) if structural edge + regime favor upside
- SELL (go SHORT) if structural edge + regime favor downside
- HOLD if no clear edge or high risk

CRITICAL: Match your vote to the regime! TRENDING_DOWN should produce SELL votes, not BUY.

Output JSON:
{{
  "vote": "BUY|SELL|HOLD",
  "confidence": 0.75,
  "reasoning": "Why you voted this way (mention regime alignment)",
  "concerns": ["Any red flags you see"]
}}"""

    def _fallback_strategy(self, asset: str, regime: str) -> Dict:
        """Fallback strategy if LLM fails."""
        return {
            "strategy_id": f"GLADIATOR_A_{self.strategy_count:04d}_FALLBACK",
            "strategy_name": f"Fallback Strategy - {asset}",
            "structural_edge": "None (fallback)",
            "entry_rules": "No entry",
            "exit_rules": "No exit",
            "filters": [],
            "risk_per_trade": 0.005,
            "expected_wr": 0.5,
            "expected_rr": 1.0,
            "why_it_works": "Fallback due to LLM failure",
            "weaknesses": ["Fallback strategy - not actionable"],
            "confidence": 0.0,
            "gladiator": "A",
            "fallback": True
        }

    # ==================== LLM API INTEGRATION ====================

    def _call_llm(
        self,
        system_prompt: str,
        user_prompt: str,
        temperature: float = 0.7,
        max_tokens: int = 2000
    ) -> str:
        """
        Call DeepSeek API with exponential backoff retry logic.
        """
        if not self.api_key:
            logger.warning("DeepSeek API key not set - using mock response")
            return self._mock_response()

        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }

        payload = {
            "model": self.MODEL,
            "messages": [
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            "temperature": temperature,
            "max_tokens": max_tokens
        }

        # Exponential backoff retry loop
        for attempt in range(self.MAX_RETRIES):
            try:
                response = requests.post(
                    self.DEEPSEEK_API_URL,
                    headers=headers,
                    json=payload,
                    timeout=60
                )
                response.raise_for_status()

                data = response.json()
                return data["choices"][0]["message"]["content"]

            except requests.exceptions.HTTPError as e:
                # Check for rate limit (429) or server errors (5xx)
                if hasattr(response, 'status_code'):
                    if response.status_code == 429 or response.status_code >= 500:
                        if attempt < self.MAX_RETRIES - 1:
                            delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                            logger.warning(
                                f"[DeepSeek] HTTP {response.status_code} - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                            )
                            time.sleep(delay)
                            continue
                logger.error(f"DeepSeek API HTTP error: {e}")
                return self._mock_response()

            except requests.exceptions.Timeout as e:
                if attempt < self.MAX_RETRIES - 1:
                    delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                    logger.warning(
                        f"[DeepSeek] Timeout - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                    )
                    time.sleep(delay)
                    continue
                logger.error(f"DeepSeek API timeout after {self.MAX_RETRIES} attempts: {e}")
                return self._mock_response()

            except requests.exceptions.RequestException as e:
                if attempt < self.MAX_RETRIES - 1:
                    delay = self.BASE_RETRY_DELAY * (2 ** attempt)
                    logger.warning(
                        f"[DeepSeek] Connection error - retry {attempt + 1}/{self.MAX_RETRIES} after {delay}s"
                    )
                    time.sleep(delay)
                    continue
                logger.error(f"DeepSeek API error after {self.MAX_RETRIES} attempts: {e}")
                return self._mock_response()

        # All retries exhausted
        logger.error("[DeepSeek] All retries exhausted")
        return self._mock_response()

    def _mock_response(self) -> str:
        """Mock response for testing without API key."""
        return """{
  "strategy_name": "London Open Volatility - Test",
  "structural_edge": "Session open volatility spike",
  "entry_rules": "Enter at London open (8AM UTC)",
  "exit_rules": "TP at 1.5R, SL at 2x ATR",
  "filters": ["spread_normal"],
  "risk_per_trade": 0.008,
  "expected_wr": 0.60,
  "expected_rr": 1.5,
  "why_it_works": "Mock strategy for testing",
  "weaknesses": ["This is a mock strategy"],
  "confidence": 0.5
}"""
