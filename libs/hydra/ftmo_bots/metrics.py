"""
FTMO Prometheus Metrics - Sharp monitoring for event-driven trading

Exposes metrics on :9100 for Prometheus scraping:
- Connection health (MT5, event bus)
- Price tick rates and latency
- Bot performance (signals, trades, P&L)
- FTMO risk metrics (drawdown, daily loss)

Usage:
    from libs.hydra.ftmo_bots.metrics import FTMOMetrics, get_ftmo_metrics

    metrics = get_ftmo_metrics()
    metrics.start_server(port=9100)

    # Record events
    metrics.record_tick("XAUUSD", latency_ms=5.2)
    metrics.record_signal("GoldLondonReversal", "XAUUSD", "BUY")
    metrics.record_trade_result("GoldLondonReversal", pnl=125.50, is_win=True)
"""

import threading
import time
from typing import Dict, Optional, Any
from dataclasses import dataclass
from loguru import logger

try:
    from prometheus_client import (
        Counter, Gauge, Histogram, Info,
        start_http_server, REGISTRY, CollectorRegistry
    )
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.warning("[Metrics] prometheus_client not available")


@dataclass
class BotStats:
    """Per-bot statistics."""
    signals_generated: int = 0
    trades_opened: int = 0
    trades_closed: int = 0
    wins: int = 0
    losses: int = 0
    total_pnl: float = 0.0
    last_signal_time: Optional[float] = None


class FTMOMetrics:
    """
    Prometheus metrics exporter for FTMO trading system.

    Metrics exposed:
    - ftmo_connection_status: MT5/Event bus connection status
    - ftmo_tick_rate: Ticks per second by symbol
    - ftmo_tick_latency_ms: Tick delivery latency
    - ftmo_bot_signals_total: Total signals generated by bot
    - ftmo_bot_trades_total: Total trades by bot and outcome
    - ftmo_bot_pnl_total: Cumulative P&L by bot
    - ftmo_account_balance: Current account balance
    - ftmo_account_equity: Current account equity
    - ftmo_daily_drawdown_percent: Today's drawdown
    - ftmo_total_drawdown_percent: Total drawdown from peak
    - ftmo_kill_switch_active: Emergency stop status
    """

    def __init__(self, registry: Optional[Any] = None):
        self._registry = registry or REGISTRY
        self._bot_stats: Dict[str, BotStats] = {}
        self._server_started = False
        self._lock = threading.Lock()

        if PROMETHEUS_AVAILABLE:
            self._init_metrics()

    def _init_metrics(self):
        """Initialize all Prometheus metrics."""
        # Connection metrics
        self.connection_status = Gauge(
            "ftmo_connection_status",
            "Connection status (1=connected, 0=disconnected)",
            ["service"],
            registry=self._registry
        )

        # Tick metrics
        self.tick_rate = Gauge(
            "ftmo_tick_rate",
            "Current tick rate per second",
            ["symbol"],
            registry=self._registry
        )

        self.tick_latency = Histogram(
            "ftmo_tick_latency_seconds",
            "Tick delivery latency in seconds",
            ["symbol"],
            buckets=[0.001, 0.005, 0.01, 0.025, 0.05, 0.1, 0.25, 0.5, 1.0],
            registry=self._registry
        )

        self.ticks_total = Counter(
            "ftmo_ticks_total",
            "Total ticks received",
            ["symbol"],
            registry=self._registry
        )

        # Price metrics
        self.current_price = Gauge(
            "ftmo_current_price",
            "Current bid price",
            ["symbol"],
            registry=self._registry
        )

        self.spread_pips = Gauge(
            "ftmo_spread_pips",
            "Current spread in pips",
            ["symbol"],
            registry=self._registry
        )

        # Bot performance metrics
        self.signals_total = Counter(
            "ftmo_bot_signals_total",
            "Total signals generated",
            ["bot", "symbol", "direction"],
            registry=self._registry
        )

        self.trades_total = Counter(
            "ftmo_bot_trades_total",
            "Total trades by outcome",
            ["bot", "outcome"],
            registry=self._registry
        )

        self.pnl_total = Gauge(
            "ftmo_bot_pnl_dollars",
            "Cumulative P&L in dollars",
            ["bot"],
            registry=self._registry
        )

        self.win_rate = Gauge(
            "ftmo_bot_win_rate",
            "Current win rate (0-1)",
            ["bot"],
            registry=self._registry
        )

        self.last_signal_age = Gauge(
            "ftmo_bot_last_signal_age_seconds",
            "Seconds since last signal",
            ["bot"],
            registry=self._registry
        )

        # Account metrics
        self.account_balance = Gauge(
            "ftmo_account_balance_dollars",
            "Current account balance",
            registry=self._registry
        )

        self.account_equity = Gauge(
            "ftmo_account_equity_dollars",
            "Current account equity",
            registry=self._registry
        )

        self.open_positions = Gauge(
            "ftmo_open_positions",
            "Number of open positions",
            registry=self._registry
        )

        self.floating_pnl = Gauge(
            "ftmo_floating_pnl_dollars",
            "Unrealized P&L of open positions",
            registry=self._registry
        )

        # Risk metrics (FTMO-specific)
        self.daily_drawdown = Gauge(
            "ftmo_daily_drawdown_percent",
            "Today's drawdown (FTMO limit: 5%)",
            registry=self._registry
        )

        self.total_drawdown = Gauge(
            "ftmo_total_drawdown_percent",
            "Total drawdown from peak (FTMO limit: 10%)",
            registry=self._registry
        )

        self.kill_switch = Gauge(
            "ftmo_kill_switch_active",
            "Emergency stop status (1=active, 0=inactive)",
            registry=self._registry
        )

        # Event bus metrics
        self.event_bus_ticks = Counter(
            "ftmo_event_bus_ticks_total",
            "Total ticks processed by event bus",
            registry=self._registry
        )

        self.event_bus_latency = Histogram(
            "ftmo_event_bus_processing_seconds",
            "Event bus tick processing time",
            buckets=[0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1],
            registry=self._registry
        )

        self.handler_errors = Counter(
            "ftmo_handler_errors_total",
            "Total handler errors",
            ["handler_type", "bot"],
            registry=self._registry
        )

        # System info
        self.system_info = Info(
            "ftmo_system",
            "System information",
            registry=self._registry
        )

        logger.info("[Metrics] Prometheus metrics initialized")

    def start_server(self, port: int = 9100):
        """Start Prometheus HTTP server."""
        if not PROMETHEUS_AVAILABLE:
            logger.error("[Metrics] Cannot start server - prometheus_client not available")
            return False

        if self._server_started:
            logger.warning("[Metrics] Server already running")
            return True

        try:
            start_http_server(port, registry=self._registry)
            self._server_started = True
            logger.info(f"[Metrics] Prometheus server started on :{port}")
            return True
        except Exception as e:
            logger.error(f"[Metrics] Failed to start server: {e}")
            return False

    # === Connection methods ===

    def set_connection_status(self, service: str, connected: bool):
        """Update connection status for a service."""
        if PROMETHEUS_AVAILABLE:
            self.connection_status.labels(service=service).set(1 if connected else 0)

    # === Tick methods ===

    def record_tick(self, symbol: str, bid: float, ask: float, latency_seconds: float):
        """Record a price tick."""
        if not PROMETHEUS_AVAILABLE:
            return

        self.ticks_total.labels(symbol=symbol).inc()
        self.tick_latency.labels(symbol=symbol).observe(latency_seconds)
        self.current_price.labels(symbol=symbol).set(bid)

        # Calculate spread in pips (assuming 5-digit for forex, 2-digit for gold)
        if symbol == "XAUUSD":
            spread = (ask - bid) * 100  # cents
        elif "USD" in symbol or "EUR" in symbol or "GBP" in symbol:
            spread = (ask - bid) * 10000  # pips
        else:
            spread = (ask - bid)  # points for indices

        self.spread_pips.labels(symbol=symbol).set(spread)

    def update_tick_rate(self, symbol: str, rate: float):
        """Update tick rate for a symbol."""
        if PROMETHEUS_AVAILABLE:
            self.tick_rate.labels(symbol=symbol).set(rate)

    # === Bot methods ===

    def record_signal(self, bot: str, symbol: str, direction: str):
        """Record a trading signal."""
        if not PROMETHEUS_AVAILABLE:
            return

        self.signals_total.labels(bot=bot, symbol=symbol, direction=direction).inc()

        with self._lock:
            if bot not in self._bot_stats:
                self._bot_stats[bot] = BotStats()
            self._bot_stats[bot].signals_generated += 1
            self._bot_stats[bot].last_signal_time = time.time()

    def record_trade_result(self, bot: str, pnl: float, is_win: bool):
        """Record a trade result."""
        if not PROMETHEUS_AVAILABLE:
            return

        outcome = "win" if is_win else "loss"
        self.trades_total.labels(bot=bot, outcome=outcome).inc()

        with self._lock:
            if bot not in self._bot_stats:
                self._bot_stats[bot] = BotStats()

            stats = self._bot_stats[bot]
            stats.trades_closed += 1
            stats.total_pnl += pnl

            if is_win:
                stats.wins += 1
            else:
                stats.losses += 1

            # Update gauges
            self.pnl_total.labels(bot=bot).set(stats.total_pnl)

            if stats.trades_closed > 0:
                win_rate = stats.wins / stats.trades_closed
                self.win_rate.labels(bot=bot).set(win_rate)

    def record_trade_opened(self, bot: str):
        """Record a trade being opened."""
        with self._lock:
            if bot not in self._bot_stats:
                self._bot_stats[bot] = BotStats()
            self._bot_stats[bot].trades_opened += 1

    def record_handler_error(self, handler_type: str, bot: str = "unknown"):
        """Record a handler error."""
        if PROMETHEUS_AVAILABLE:
            self.handler_errors.labels(handler_type=handler_type, bot=bot).inc()

    # === Account methods ===

    def update_account(self, balance: float, equity: float, positions: int, floating_pnl: float):
        """Update account metrics."""
        if not PROMETHEUS_AVAILABLE:
            return

        self.account_balance.set(balance)
        self.account_equity.set(equity)
        self.open_positions.set(positions)
        self.floating_pnl.set(floating_pnl)

    # === Risk methods ===

    def update_risk_metrics(self, daily_dd: float, total_dd: float, kill_switch: bool):
        """Update FTMO risk metrics."""
        if not PROMETHEUS_AVAILABLE:
            return

        self.daily_drawdown.set(daily_dd)
        self.total_drawdown.set(total_dd)
        self.kill_switch.set(1 if kill_switch else 0)

    # === Event bus methods ===

    def record_event_bus_tick(self, processing_time: float):
        """Record event bus tick processing."""
        if PROMETHEUS_AVAILABLE:
            self.event_bus_ticks.inc()
            self.event_bus_latency.observe(processing_time)

    # === System methods ===

    def set_system_info(self, version: str, mode: str, bots: str):
        """Set system information."""
        if PROMETHEUS_AVAILABLE:
            self.system_info.info({
                "version": version,
                "mode": mode,
                "bots": bots
            })

    def update_signal_ages(self):
        """Update last signal age for all bots."""
        if not PROMETHEUS_AVAILABLE:
            return

        now = time.time()
        with self._lock:
            for bot, stats in self._bot_stats.items():
                if stats.last_signal_time:
                    age = now - stats.last_signal_time
                    self.last_signal_age.labels(bot=bot).set(age)

    def get_bot_stats(self, bot: str) -> Optional[BotStats]:
        """Get stats for a specific bot."""
        with self._lock:
            return self._bot_stats.get(bot)

    def get_all_stats(self) -> Dict[str, Any]:
        """Get all metrics as a dictionary (for non-Prometheus use)."""
        with self._lock:
            return {
                "bots": {
                    name: {
                        "signals": stats.signals_generated,
                        "trades": stats.trades_closed,
                        "wins": stats.wins,
                        "losses": stats.losses,
                        "pnl": stats.total_pnl,
                        "win_rate": stats.wins / stats.trades_closed if stats.trades_closed > 0 else 0
                    }
                    for name, stats in self._bot_stats.items()
                }
            }


# Singleton instance
_metrics: Optional[FTMOMetrics] = None
_metrics_lock = threading.Lock()


def get_ftmo_metrics() -> FTMOMetrics:
    """Get singleton metrics instance."""
    global _metrics
    if _metrics is None:
        with _metrics_lock:
            if _metrics is None:
                _metrics = FTMOMetrics()
    return _metrics
