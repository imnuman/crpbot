"""
HYDRA 4.0 - Turbo Strategy Generator

Generates 1000 unique trading strategies in a single LLM batch call.
Uses Claude's 200K context to create diverse strategy variations.

Cost: ~$1.50 per 1000 strategies
"""

import json
import logging
import random
from dataclasses import dataclass, field
from datetime import datetime, timezone
from typing import List, Dict, Any, Optional
from enum import Enum

import anthropic

logger = logging.getLogger(__name__)


class StrategyType(Enum):
    """Strategy specialization types matching engine specialties."""
    LIQUIDATION_CASCADE = "liquidation_cascade"
    FUNDING_EXTREME = "funding_extreme"
    ORDERBOOK_IMBALANCE = "orderbook_imbalance"
    REGIME_TRANSITION = "regime_transition"


@dataclass
class GeneratedStrategy:
    """A strategy generated by the turbo generator."""
    strategy_id: str
    name: str
    specialty: StrategyType
    regime: str
    asset_class: str

    # Entry conditions
    entry_rules: Dict[str, Any] = field(default_factory=dict)

    # Exit conditions
    exit_rules: Dict[str, Any] = field(default_factory=dict)

    # Risk parameters
    risk_per_trade: float = 0.01
    stop_loss_atr_mult: float = 1.5
    take_profit_atr_mult: float = 2.25
    max_holding_hours: int = 24

    # Thresholds
    min_confidence: float = 0.70
    specialty_threshold: float = 0.0

    # Metadata
    generation: int = 0
    created_at: str = field(default_factory=lambda: datetime.now(timezone.utc).isoformat())
    parent_ids: List[str] = field(default_factory=list)

    # Performance (to be filled by ranker)
    backtest_wr: float = 0.0
    backtest_sharpe: float = 0.0
    backtest_max_dd: float = 0.0
    backtest_trades: int = 0
    rank_score: float = 0.0

    # Paper trading (to be filled by paper gate)
    paper_trades: int = 0
    paper_wr: float = 0.0
    paper_pnl: float = 0.0

    def to_dict(self) -> Dict[str, Any]:
        return {
            "strategy_id": self.strategy_id,
            "name": self.name,
            "specialty": self.specialty.value,
            "regime": self.regime,
            "asset_class": self.asset_class,
            "entry_rules": self.entry_rules,
            "exit_rules": self.exit_rules,
            "risk_per_trade": self.risk_per_trade,
            "stop_loss_atr_mult": self.stop_loss_atr_mult,
            "take_profit_atr_mult": self.take_profit_atr_mult,
            "max_holding_hours": self.max_holding_hours,
            "min_confidence": self.min_confidence,
            "specialty_threshold": self.specialty_threshold,
            "generation": self.generation,
            "created_at": self.created_at,
            "parent_ids": self.parent_ids,
            "backtest_wr": self.backtest_wr,
            "backtest_sharpe": self.backtest_sharpe,
            "backtest_max_dd": self.backtest_max_dd,
            "backtest_trades": self.backtest_trades,
            "rank_score": self.rank_score,
            "paper_trades": self.paper_trades,
            "paper_wr": self.paper_wr,
            "paper_pnl": self.paper_pnl,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "GeneratedStrategy":
        data = data.copy()
        if isinstance(data.get("specialty"), str):
            data["specialty"] = StrategyType(data["specialty"])
        return cls(**data)


class TurboGenerator:
    """
    Generates large batches of trading strategies using Claude API.

    Features:
    - Generates 1000 unique strategies per batch
    - Varies parameters across full range
    - Outputs structured JSON for easy parsing
    - Cost-effective: ~$1.50 per 1000 strategies
    """

    # Parameter ranges for strategy variation
    PARAM_RANGES = {
        "liquidation_threshold": (5_000_000, 50_000_000),  # $5M to $50M
        "funding_rate_threshold": (0.1, 1.5),  # 0.1% to 1.5%
        "orderbook_ratio_threshold": (1.5, 5.0),  # 1.5:1 to 5:1
        "atr_multiplier_threshold": (1.2, 3.0),  # 1.2x to 3x ATR expansion
        "stop_loss_atr": (1.0, 3.0),
        "take_profit_atr": (1.5, 4.5),
        "risk_per_trade": (0.005, 0.02),  # 0.5% to 2%
        "min_confidence": (0.60, 0.85),
        "max_holding_hours": (4, 72),
    }

    REGIMES = ["TRENDING_UP", "TRENDING_DOWN", "RANGING", "VOLATILE"]
    ASSET_CLASSES = ["BTC", "ETH", "ALTCOIN", "ALL"]

    def __init__(self, api_key: Optional[str] = None):
        """Initialize the turbo generator."""
        import os
        self.api_key = api_key or os.getenv("ANTHROPIC_API_KEY")
        if not self.api_key:
            logger.warning("[TurboGenerator] No Anthropic API key - using mock mode")
            self.client = None
        else:
            self.client = anthropic.Anthropic(api_key=self.api_key)

        self._strategy_counter = 0
        logger.info("[TurboGenerator] Initialized")

    def generate_batch(
        self,
        specialty: StrategyType,
        regime: Optional[str] = None,
        asset_class: Optional[str] = None,
        count: int = 100,
        use_mock: bool = False
    ) -> List[GeneratedStrategy]:
        """
        Generate a batch of strategies.

        Args:
            specialty: The engine specialty to generate strategies for
            regime: Market regime (optional, generates for all if None)
            asset_class: Asset class (optional, generates for all if None)
            count: Number of strategies to generate (default 100, max 1000)
            use_mock: Use mock generation instead of API

        Returns:
            List of GeneratedStrategy objects
        """
        count = min(count, 1000)  # Cap at 1000 per batch

        if use_mock or not self.client:
            logger.info(f"[TurboGenerator] Mock generating {count} {specialty.value} strategies")
            return self._generate_mock_batch(specialty, regime, asset_class, count)

        logger.info(f"[TurboGenerator] Generating {count} {specialty.value} strategies via Claude API")

        try:
            prompt = self._build_mega_prompt(specialty, regime, asset_class, count)

            response = self.client.messages.create(
                model="claude-sonnet-4-20250514",
                max_tokens=100000,
                messages=[{"role": "user", "content": prompt}]
            )

            # Parse response
            content = response.content[0].text
            strategies = self._parse_response(content, specialty)

            # Log cost estimate
            input_tokens = response.usage.input_tokens
            output_tokens = response.usage.output_tokens
            cost = (input_tokens * 0.003 + output_tokens * 0.015) / 1000
            logger.info(f"[TurboGenerator] Generated {len(strategies)} strategies, cost: ${cost:.4f}")

            return strategies

        except Exception as e:
            logger.error(f"[TurboGenerator] API error: {e}, falling back to mock")
            return self._generate_mock_batch(specialty, regime, asset_class, count)

    def _build_mega_prompt(
        self,
        specialty: StrategyType,
        regime: Optional[str],
        asset_class: Optional[str],
        count: int
    ) -> str:
        """Build the mega-prompt for batch strategy generation."""

        specialty_details = self._get_specialty_details(specialty)
        regimes = [regime] if regime else self.REGIMES
        assets = [asset_class] if asset_class else self.ASSET_CLASSES

        prompt = f"""You are a quantitative trading strategy generator. Generate exactly {count} unique trading strategies.

## SPECIALTY: {specialty.value.upper()}
{specialty_details}

## REQUIREMENTS
Each strategy must be unique with different:
- Parameter thresholds (vary within ranges)
- Entry conditions (different combinations)
- Exit conditions (different SL/TP ratios)
- Risk parameters

## PARAMETER RANGES TO VARY
- specialty_threshold: {self.PARAM_RANGES.get(f'{specialty.value.split("_")[0]}_threshold', (0, 1))}
- stop_loss_atr: {self.PARAM_RANGES['stop_loss_atr']}
- take_profit_atr: {self.PARAM_RANGES['take_profit_atr']}
- risk_per_trade: {self.PARAM_RANGES['risk_per_trade']}
- min_confidence: {self.PARAM_RANGES['min_confidence']}
- max_holding_hours: {self.PARAM_RANGES['max_holding_hours']}

## REGIMES TO COVER
{regimes}

## ASSET CLASSES TO COVER
{assets}

## OUTPUT FORMAT
Output a JSON array of {count} strategy objects. Each object must have:
```json
{{
  "name": "descriptive_name_here",
  "regime": "TRENDING_UP|TRENDING_DOWN|RANGING|VOLATILE",
  "asset_class": "BTC|ETH|ALTCOIN|ALL",
  "entry_rules": {{
    "primary_trigger": "description",
    "confirmation": "description",
    "filter": "description"
  }},
  "exit_rules": {{
    "take_profit": "description",
    "stop_loss": "description",
    "time_exit": "description"
  }},
  "risk_per_trade": 0.01,
  "stop_loss_atr_mult": 1.5,
  "take_profit_atr_mult": 2.25,
  "max_holding_hours": 24,
  "min_confidence": 0.70,
  "specialty_threshold": 0.5
}}
```

Generate diverse strategies - no duplicates. Vary ALL parameters significantly between strategies.
Output ONLY the JSON array, no other text."""

        return prompt

    def _get_specialty_details(self, specialty: StrategyType) -> str:
        """Get detailed description for each specialty."""
        details = {
            StrategyType.LIQUIDATION_CASCADE: """
Liquidation Cascade Trading:
- Trigger: Large forced liquidations ($5M-$50M+) causing price cascades
- Entry: After detecting liquidation spike, trade the continuation or reversal
- Key metrics: liquidation volume, liquidation direction (longs/shorts), cascade velocity
- Best regimes: VOLATILE, TRENDING (with the cascade direction)
""",
            StrategyType.FUNDING_EXTREME: """
Funding Rate Extreme Trading:
- Trigger: Funding rates at extremes (>0.1% to >1.5% per 8h)
- Entry: Fade crowded trades when funding is extreme
- Key metrics: funding rate %, open interest, funding rate velocity
- Best regimes: RANGING (mean reversion), TRENDING (continuation after reset)
""",
            StrategyType.ORDERBOOK_IMBALANCE: """
Orderbook Imbalance Trading:
- Trigger: Heavy one-sided pressure (bid/ask ratio 1.5:1 to 5:1)
- Entry: Trade with the imbalance or fade it at extremes
- Key metrics: bid/ask ratio, depth imbalance, order flow
- Best regimes: ALL (adapts to regime)
""",
            StrategyType.REGIME_TRANSITION: """
Regime Transition Trading:
- Trigger: Volatility expansion (ATR 1.2x-3x normal)
- Entry: Catch early trend moves during regime changes
- Key metrics: ATR multiplier, ADX change, Bollinger width expansion
- Best regimes: Transition from RANGING to TRENDING
"""
        }
        return details.get(specialty, "Unknown specialty")

    def _parse_response(self, content: str, specialty: StrategyType) -> List[GeneratedStrategy]:
        """Parse LLM response into strategy objects."""
        strategies = []

        try:
            # Find JSON array in response
            start = content.find('[')
            end = content.rfind(']') + 1
            if start == -1 or end == 0:
                logger.error("[TurboGenerator] No JSON array found in response")
                return strategies

            json_str = content[start:end]
            raw_strategies = json.loads(json_str)

            for raw in raw_strategies:
                try:
                    strategy = self._raw_to_strategy(raw, specialty)
                    if self._validate_strategy(strategy):
                        strategies.append(strategy)
                except Exception as e:
                    logger.debug(f"[TurboGenerator] Failed to parse strategy: {e}")
                    continue

            logger.info(f"[TurboGenerator] Parsed {len(strategies)}/{len(raw_strategies)} strategies")

        except json.JSONDecodeError as e:
            logger.error(f"[TurboGenerator] JSON parse error: {e}")

        return strategies

    def _raw_to_strategy(self, raw: Dict[str, Any], specialty: StrategyType) -> GeneratedStrategy:
        """Convert raw dict to GeneratedStrategy object."""
        self._strategy_counter += 1

        return GeneratedStrategy(
            strategy_id=f"TURBO_{specialty.value[:4].upper()}_{self._strategy_counter:06d}",
            name=raw.get("name", f"strategy_{self._strategy_counter}"),
            specialty=specialty,
            regime=raw.get("regime", "ALL"),
            asset_class=raw.get("asset_class", "ALL"),
            entry_rules=raw.get("entry_rules", {}),
            exit_rules=raw.get("exit_rules", {}),
            risk_per_trade=float(raw.get("risk_per_trade", 0.01)),
            stop_loss_atr_mult=float(raw.get("stop_loss_atr_mult", 1.5)),
            take_profit_atr_mult=float(raw.get("take_profit_atr_mult", 2.25)),
            max_holding_hours=int(raw.get("max_holding_hours", 24)),
            min_confidence=float(raw.get("min_confidence", 0.70)),
            specialty_threshold=float(raw.get("specialty_threshold", 0.5)),
            generation=0,
        )

    def _validate_strategy(self, strategy: GeneratedStrategy) -> bool:
        """Quick validation of strategy parameters."""
        # Check required fields
        if not strategy.strategy_id or not strategy.name:
            return False

        # Check parameter ranges
        if not (0.005 <= strategy.risk_per_trade <= 0.03):
            return False
        if not (0.5 <= strategy.stop_loss_atr_mult <= 5.0):
            return False
        if not (1.0 <= strategy.take_profit_atr_mult <= 6.0):
            return False
        if not (0.5 <= strategy.min_confidence <= 0.95):
            return False

        return True

    def _generate_mock_batch(
        self,
        specialty: StrategyType,
        regime: Optional[str],
        asset_class: Optional[str],
        count: int
    ) -> List[GeneratedStrategy]:
        """Generate mock strategies for testing."""
        strategies = []
        regimes = [regime] if regime else self.REGIMES
        assets = [asset_class] if asset_class else self.ASSET_CLASSES

        for i in range(count):
            self._strategy_counter += 1

            # Randomize parameters
            sl_atr = round(random.uniform(*self.PARAM_RANGES["stop_loss_atr"]), 2)
            tp_atr = round(sl_atr * random.uniform(1.2, 2.0), 2)  # TP > SL

            strategy = GeneratedStrategy(
                strategy_id=f"TURBO_{specialty.value[:4].upper()}_{self._strategy_counter:06d}",
                name=f"{specialty.value}_{random.choice(regimes).lower()}_{i}",
                specialty=specialty,
                regime=random.choice(regimes),
                asset_class=random.choice(assets),
                entry_rules={
                    "primary_trigger": f"{specialty.value} detected",
                    "confirmation": "momentum aligned",
                    "filter": "no major news"
                },
                exit_rules={
                    "take_profit": f"{tp_atr}x ATR",
                    "stop_loss": f"{sl_atr}x ATR",
                    "time_exit": f"{random.randint(4, 48)} hours"
                },
                risk_per_trade=round(random.uniform(*self.PARAM_RANGES["risk_per_trade"]), 3),
                stop_loss_atr_mult=sl_atr,
                take_profit_atr_mult=tp_atr,
                max_holding_hours=random.randint(*self.PARAM_RANGES["max_holding_hours"]),
                min_confidence=round(random.uniform(*self.PARAM_RANGES["min_confidence"]), 2),
                specialty_threshold=round(random.uniform(0.3, 0.8), 2),
                generation=0,
            )

            strategies.append(strategy)

        return strategies

    def generate_all_specialties(
        self,
        count_per_specialty: int = 250,
        use_mock: bool = False
    ) -> Dict[StrategyType, List[GeneratedStrategy]]:
        """Generate strategies for all 4 specialties."""
        results = {}

        for specialty in StrategyType:
            logger.info(f"[TurboGenerator] Generating {count_per_specialty} {specialty.value} strategies")
            strategies = self.generate_batch(
                specialty=specialty,
                count=count_per_specialty,
                use_mock=use_mock
            )
            results[specialty] = strategies
            logger.info(f"[TurboGenerator] Generated {len(strategies)} {specialty.value} strategies")

        total = sum(len(s) for s in results.values())
        logger.info(f"[TurboGenerator] Total strategies generated: {total}")

        return results


# Singleton instance
_generator_instance: Optional[TurboGenerator] = None


def get_turbo_generator() -> TurboGenerator:
    """Get or create the turbo generator singleton."""
    global _generator_instance
    if _generator_instance is None:
        _generator_instance = TurboGenerator()
    return _generator_instance
